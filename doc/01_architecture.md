# Logist Architecture

## Core Terminology

### Logist (Tool/Project)
Logist is the primary orchestration tool that manages the execution of isolated, persistent jobs. It uses a Node.js-based tool, **`cline`**, as the fundamental execution primitive for running agentic tasks. It handles state management, resource tracking, Git safety practices, and flow control between automated agents and human checkpoints.

### Job (Unit of Work)
A **Job** represents a single, self-contained unit of work that requires persistent execution across multiple agent interactions. Each job is completely isolated - the Logist clones the current Git state before beginning work, creating a baseline hash that ensures safety and allows complete rollback if needed.

### Agent Run (Execution Step)
An **Agent Run** is a single execution of a Cline CLI command by a specialized agent (Worker or Supervisor). Each run either advances the job state or signals that human intervention (via The Steward) is required.

### Jobs Index (`jobs_index.json`)
The **Jobs Index** is the central registry for all jobs managed by Logist. Located in the user's configurable jobs directory (specified with `--jobs-dir`, defaulting to `~/.logist/jobs`), this file maintains two key pieces of information:
-   `current_job_id`: A global pointer to the currently selected job, allowing users to run commands like `logist job status` without specifying a job ID.
-   `jobs`: A mapping between a `job_id` and the absolute path to that job's directory on the filesystem.

It is the source of truth for locating jobs and understanding which job is currently active.

### Job Manifest (`job_manifest.json`)
The **Job Manifest** is the primary state file located *within each individual job's directory*. It is the single source of truth for a specific job, storing:
- Current job status (`PENDING`, `RUNNING`, `STUCK`, etc.) and execution phase.
- A history of all Agent Runs and Steward interventions.
- Evidence files generated by each agent run.
- Cumulative metrics (cost, time).
- Git context (baseline hash, job branch name).
- `acceptance_criteria_from_prompt`: The user-defined goal for the job (e.g., "all tests pass").
- `is_goal_achieved`: A boolean flag set by an agent when it determines the goal has been met.
- `final_stop_reason`: A string explaining why the job halted, whether by success, hitting a limit, or error.

### The Steward (Human Checkpoint)
The **Steward** represents human intervention points in the workflow. When a job reaches an ambiguous state (STUCK), completes a major phase, or encounters errors, execution pauses and waits for human review and direction before continuing.

## Execution Philosophy

### Job Isolation (Safety First)
Every job begins by creating a complete, isolated Git environment to ensure that the main project repository remains untouched during an agent's work. This is achieved through a sophisticated git worktree, branch, and bare repository setup that provides robust isolation while maintaining seamless git operations.

#### Advanced Isolation Architecture
The isolation system uses:
- **Job-Specific Branches**: Each job creates a dedicated branch (e.g., `job-{job_id}`) from the specified base branch
- **Bare Repository (`target.git`)**: A minimal bare repository clone containing all git history for the job branch
- **Symlinked Worktree**: The workspace directory uses a symlinked `.git` file pointing to the bare repository, enabling transparent git operations within the workspace
- **Automatic Setup**: The prepare-python-project.sh script is automatically executed if available to ensure the workspace is properly initialized

This isolated environment serves as a staging area where "coder" agents can perform their work, including making a series of local Git commits with descriptive messages.

Key components of this strategy include:
- **Baseline Hash**: The commit hash of the original repository at the moment the job branch is created, providing a clean rollback point
- **Local Commits**: Agents commit their changes within the isolated worktree, preserving detailed history specific to the job
- **Branch Isolation**: Each job operates in its own branch, preventing conflicts between concurrent jobs
- **Transparent Git Operations**: All git commands work seamlessly through the symlinked `.git` due to proper GIT_DIR and GIT_WORK_TREE environment configuration
- **Future Integration**: The job branches provide a foundation for future patch file generation or merge proposals back into the main repository, subject to human (Steward) approval

#### Workspace Creation Timing
Job workspaces are created **lazily** during execution commands to avoid unnecessary resource usage:

**Commands that Create Workspaces:**
- `logist job step [JOB_ID]` - Creates workspace for single-step execution
- `logist job run [JOB_ID]` - Creates workspace for continuous execution
- `logist job rerun [JOB_ID]` - Creates workspace for job restart
- `logist job restep [JOB_ID]` - Creates workspace for checkpoint restoration
- `logist job activate [JOB_ID]` *(planned)* - Will create workspace immediately upon job activation

**How Workspace Creation Works (Idempotent):**
1. **Validation**: `setup_isolated_workspace()` first validates if existing `target.git` and `workspace` are present and correctly configured for the job branch
2. **Reuse**: If valid existing setups exist, they are reused to avoid unnecessary work and preserve uncommitted changes
3. **Creation**: If validation fails or no existing setup exists:
   - A job-specific branch is created from the base branch
   - A bare repository clone (`target.git`) is created for the job branch to store git history
   - Git worktree adds a detached worktree, then adjusts `.git` to symlink to `../target.git`
4. The `prepare-python-project.sh` script is automatically executed if available to prepare the workspace
5. If `attachments/` directory exists, contents are copied to `workspace/attachments/`
6. The workspace is now ready for Cline CLI execution with transparent git operations through the symlinked `.git`
7. Workspaces are automatically cleaned up based on policies (successful jobs after 1 day, failed after 7 days, etc.), removing both `workspace/` and `target.git/`

### Iterative Loop Structure
The Logist enforces a strict three-phase execution loop:

1. **Worker Run (Action)**: Agent executes actual work, generating outputs and evidence files
2. **Supervisor Run (Evaluation)**: Agent reviews work quality, identifies issues, provides guidance
3. **Steward Checkpoint (Human Gate)**: Human reviews progress and decides next action

This cycle repeats until the job reaches COMPLETED status or encounters an unrecoverable error.

### Flow Control Logic
- **COMPLETED**: Worker signals job success - Logist advances to final Steward review
- **STUCK**: Worker needs clarification - pauses for Steward intervention
- **RETRY**: Supervisor recommends restarting current phase - Logist re-runs without human intervention

### Non-Destructive Previews (Dry Runs)
To aid in debugging, cost control, and build confidence in agent actions, Logist provides non-destructive preview and dry-run capabilities. These features allow users to inspect the agent's planned actions and generated prompts without incurring actual costs or modifying the project state.

-   **Prompt Preview**: Allows viewing the exact prompt intended for the next agent run without executing it.
-   **Dry Run Simulation**: Simulates an entire Worker -> Supervisor execution cycle using mock data, demonstrating the logical flow and data transformations without actual LLM calls or state changes.

## Modular Architecture (v2.0)

### Architectural Evolution
The Logist codebase has been refactored from a monolithic CLI structure to a modular, service-oriented architecture. This refactoring addresses the growing complexity of the CLI implementation by separating concerns and enabling better testability and maintainability.

### Core Components

#### 1. CLI Layer (`cli.py`)
The command-line interface now serves as a thin orchestration layer that:
- Parses user arguments and options
- Manages global context and configuration
- Dispatches commands to appropriate service layers
- Handles user interaction (prompts, confirmations, colored output)

The CLI layer is intentionally lightweight and focuses on user experience rather than business logic.

#### 2. Core Engine (`core_engine.py`)
The `LogistEngine` class handles the primary job execution orchestration logic including:
- **Job stepping**: Single-phase execution with workspace preparation and LLM invocation
- **Job running**: Continuous execution until completion or intervention
- **Job rerunning**: Restart capability with state reset and phase skipping
- **Job restepping**: Checkpoint restoration within a run
- **History management**: Debug logging and job history persistence
- **Execution coordination**: Integration between job processor, context assembly, and workspace utilities

The Core Engine represents the "brain" of the system - orchestrating the complex interactions between jobs, agents, and the filesystem.

#### 3. Service Layer (`services/`)
Specialized service classes handle domain-specific operations:

##### JobManagerService (`services/job_manager.py`)
Manages job lifecycle and metadata operations:
- Job creation and registration with the jobs index
- Job selection and status retrieval
- Job listing and inspection
- Workspace setup and isolation
- Job history and manifest management

##### RoleManagerService (`services/role_manager.py`)
Handles agent role configuration and loading:
- Role discovery from configuration files
- Role inspection and content retrieval
- Role validation and metadata management

### Architectural Benefits

#### Improved Testability
- Each service can be unit tested in isolation
- Mock dependencies enable focused testing of individual components
- Service interfaces allow for easy integration testing
- Clear separation enables comprehensive test coverage

#### Enhanced Maintainability
- Single Responsibility Principle: Each module has a clear, focused purpose
- Reduced coupling between components
- Easier debugging: Issues can be isolated to specific layers
- Code reusability: Services can be used across different CLI commands

#### Better Developer Experience
- Faster development cycles with modular components
- Clear interfaces between services
- Easier onboarding: New developers can understand individual services without the full system complexity
- Incremental feature development: New functionality can be added to specific services

#### Scalability Considerations
- Service layer enables future API development (REST, GraphQL)
- Modular design supports microservice evolution if needed
- Clear boundaries enable parallel development by multiple team members
- Component isolation supports performance optimization of individual services

### Migration Path
The refactoring maintains full backward compatibility while providing a foundation for future enhancements:

1. **CLI Layer**: Commands work identically, only internal delegation changed
2. **Service APIs**: Stable interfaces enable reliable integration
3. **Testing**: Comprehensive unit tests ensure functionality preservation
4. **Documentation**: Updated to reflect new architectural boundaries

### Future Extensions
The modular architecture enables several future enhancements:

- **Web UI**: Service layer can support REST API endpoints
- **Configuration Management**: Services can support multiple backends
- **Plugin Architecture**: Well-defined interfaces enable extensibility
- **Advanced Monitoring**: Service metrics and health checks
- **Multi-tenancy**: Service isolation supports concurrent users

This architectural evolution positions Logist for continued growth while maintaining its core strengths in job orchestration and agent management.